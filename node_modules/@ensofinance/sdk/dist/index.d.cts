/**
 * Route action using Enso's routing engine.
 */
type RouteAction = {
    /** Must be 'enso' for route actions */
    protocol: "enso";
    /** Action type */
    action: "route";
    /** Action arguments matching OpenAPI spec */
    args: {
        /** Input token address */
        tokenIn: Address;
        /** Output token address */
        tokenOut: Address;
        /** Amount to route in wei (with full decimals) */
        amountIn: ActionOutputReference<Quantity>;
        /** Slippage tolerance in basis points (100 = 1%) */
        slippage?: Quantity;
        /** Address to receive the output tokens if not the caller */
        receiver?: Address;
        /** Optional address of the router or primary contract to use */
        primaryAddress?: Address;
        /** Optional pool fee in basis points when using specific pools */
        poolFee?: Quantity;
        /** The minimum amount out */
        minAmountOut?: Quantity;
        /** The fee in basis points */
        fee?: Quantity;
        /** Fee receiver */
        feeReceiver?: Address;
        /** A list of aggregators to be ignored from consideration */
        ignoreAggregators?: string[];
        /** A list of standards to be ignored from consideration */
        ignoreStandards?: string[];
    };
};
/**
 * Get balance of a token.
 */
type BalanceAction = {
    /** Must be 'enso' for balance actions */
    protocol: "enso";
    /** Action type */
    action: "balance";
    /** Action arguments */
    args: {
        /** Address of the token to check balance */
        token: Address;
    };
};
/**
 *  Approve token spending.
 */
type ApproveAction = {
    /** Protocol to approve for */
    protocol: "erc20";
    /** Action type */
    action: "approve";
    /** Action arguments */
    args: {
        /** Token to approve */
        token: Address;
        /** Spender address (protocol or router) */
        spender: Address;
        /** Amount to approve in wei (with full decimals) */
        amount: ActionOutputReference<Quantity>;
        /** Routing strategy must be router */
        routingStrategy?: "router";
    };
};
/**
 *  Borrow tokens from a lending protocol.
 */
type BorrowAction = {
    /** Protocol to borrow from */
    protocol: string;
    /** Action type */
    action: "borrow";
    /** Action arguments */
    args: {
        /** Collateral token address(es) */
        collateral: Address | Address[];
        /** Token to borrow */
        tokenOut: Address;
        /** Amount to borrow in wei (with full decimals) */
        amountOut: ActionOutputReference<Quantity>;
        /** Address of the lending pool contract */
        primaryAddress: Address;
    };
};
/**
 * Harvest rewards from a protocol.
 */
type HarvestAction = {
    /** Action type */
    action: "harvest";
    /** Protocol to harvest from */
    protocol: string;
    /** Action arguments */
    args: {
        /** Token to harvest */
        token: Address;
        /** Primary contract address */
        primaryAddress: Address;
    };
};
/**
 *  Repay a loan to a lending protocol.
 */
type RepayAction = {
    /** Protocol to repay to */
    protocol: string;
    /** Action type */
    action: "repay";
    /** Action arguments */
    args: {
        /** Token to repay with */
        tokenIn: Address;
        /** Amount to repay in wei (with full decimals) */
        amountIn: ActionOutputReference<Quantity>;
        /** Address of the lending pool contract */
        primaryAddress: Address;
        /** The address of the user whose debt is being repaid" */
        onBehalfOf?: Address;
    };
};
/**
 * Call arbitrary contract method.
 */
type CallAction = {
    /** Action type */
    action: "call";
    /** Protocol to interact with */
    protocol: string;
    /** Action arguments */
    args: {
        /** Contract address to call */
        address: Address;
        /** Method to call */
        method: string;
        /** ABI of the method */
        abi: string;
        /** Arguments for the method */
        args: any[];
    };
};
/**
 * Splits an amount into multiple parts based on specified percentages.
 *
 */
type SplitAction = {
    /** Must be 'enso' for split actions */
    protocol: "enso";
    /** Action type */
    action: "split";
    /** Action arguments */
    args: {
        /** The token to split */
        tokenIn: Address;
        tokenOut: Address[];
        amountIn: ActionOutputReference<Quantity>;
        receiver?: Address;
    };
};
/**
 * Merge multiple token inputs into a single output.
 */
type MergeAction = {
    /** Must be 'enso' for merge actions */
    protocol: "enso";
    /** Action type */
    action: "merge";
    /** Action arguments */
    args: {
        /** Address of token to input */
        tokenIn: Address[];
        /** Address of token to receive */
        tokenOut: Address;
        /** The amount to send */
        amountIn: ActionOutputReference<Quantity>[];
        /** The receiver account */
        receiver?: Address;
    };
};
/**
 * Minimum amount out action - provides slippage protection with `minAmountOut` as threshold.
 */
type MinAmountOutAction = {
    /** Must be 'enso' for minAmountOut actions */
    protocol: "enso";
    /** Action type */
    action: "minamountout";
    /** Action arguments */
    args: {
        /** Expected output amount in wei (with full decimals) */
        amountOut: StrictOutputReference<Quantity>;
        /** Minimum acceptable amount */
        minAmountOut: ActionOutputReference<Quantity>;
    };
};
/**
 *  Slippage action.
 */
type SlippageAction = {
    /** Must be 'enso' for slippage actions */
    protocol: "enso";
    /** Action type */
    action: "slippage";
    /** Action arguments */
    args: {
        /** Maximum acceptable slippage in basis points (1 bps = 0.01%, 100 bps = 1%) */
        bps: Quantity;
        /** Expected output amount (with full decimals) or a return value from a previous action */
        amountOut: StrictOutputReference<Quantity>;
    };
};
type ActionOutputReference<T> = T | StrictOutputReference<T>;
type StrictOutputReference<T> = {
    useOutputOfCallAt: number;
    index?: number;
};
/**
 * Fee action - calculates and deducts a fee from a specified amount.
 */
type FeeAction = {
    /** Must be 'enso' for fee actions */
    protocol: "enso";
    /** Action type */
    action: "fee";
    /** Action arguments */
    args: {
        /** Token address to apply the fee to */
        token: Address;
        /** Amount to apply the fee to (with full decimals) */
        amount: ActionOutputReference<Quantity>;
        /** Fee percentage in basis points (1 bps = 0.01%, 100 bps = 1%) */
        bps: Quantity;
        /** Address to receive the fee */
        receiver: Address;
    };
};
/**
 *  Enso fee action.
 */
type EnsoFeeAction = {
    /** Must be 'enso' for ensofee actions */
    protocol: "enso";
    /** Action type */
    action: "ensofee";
    /** Action arguments */
    args: {
        /** Token address to apply the fee to */
        token: Address;
        /** Amount to apply the fee to (with full decimals) */
        amount: ActionOutputReference<Quantity>;
        /** Fee percentage in basis points (1 bps = 0.01%, 100 bps = 1%) */
        bps: Quantity;
    };
};
/**
 *  Deposit tokens to a protocol.
 */
type DepositAction = {
    /** Protocol to deposit to */
    protocol: string;
    /** Action type */
    action: "deposit";
    /** Action arguments */
    args: {
        /** Input token(s) - can be single address or array for multiple tokens */
        tokenIn: Address | Address[];
        /** Output token(s) - can be single address or array for multiple tokens */
        tokenOut?: Address | Address[];
        /** Amount to deposit - can be single value or array for multiple tokens */
        amountIn: ActionOutputReference<Quantity> | ActionOutputReference<Quantity>[];
        /** Address of the protocol contract to interact with */
        primaryAddress: Address;
        /** Address to receive the output tokens if not the caller */
        receiver?: Address;
    };
};
/**
 *  Redeem tokens from a protocol.
 */
type RedeemAction = {
    /** Protocol to redeem from */
    protocol: string;
    /** Action type */
    action: "redeem";
    /** Action arguments */
    args: {
        /** Input token address (shares/tokens to redeem) */
        tokenIn?: Address;
        /** Output token(s) - can be single address or array for multiple tokens */
        tokenOut: Address | Address[];
        /** Amount to redeem in wei (with full decimals) */
        amountIn: ActionOutputReference<Quantity>;
        /** Address of the contract to interact with */
        primaryAddress: Address;
        /** Address to receive the output tokens if not the caller */
        receiver?: Address;
    };
};
/**
 * Bridge tokens across chains.
 */
type BridgeAction = {
    /** Action type */
    action: "bridge";
    /** Protocol to use for bridging */
    protocol: "stargate";
    /** Action arguments */
    args: {
        /** Input token address */
        tokenIn: Address;
        /** Amount to bridge */
        amountIn: ActionOutputReference<Quantity>;
        /** Primary contract address (bridging protocol) */
        primaryAddress: Address;
        /** Destination chain ID */
        destinationChainId: number;
        /** Receiver address on destination chain */
        receiver: Address;
        /** Optional callback data to execute on the destination chain. The callback bundle MUST start with a balance action */
        callback?: BundleAction[];
        /** Optional callback execution gas costs */
        callbackGasLimit?: string;
        /** Optional fee to pay in native asset */
        bridgeFee?: string;
    };
};
/**
 * Deposit into a Concentrated Liquidity Market Maker (CLMM) position.
 */
type DepositCLMMAction = {
    /** Protocol to deposit to */
    protocol: string;
    /** Action type */
    action: "depositclmm";
    /** Action arguments */
    args: {
        /** Input token addresses */
        tokenIn: Address[];
        /** Output token address */
        tokenOut: Address;
        /** Amount of tokens to deposit */
        amountIn: ActionOutputReference<Quantity>[];
        /** Ticks for the deposit */
        ticks: Quantity[];
        /** Fee for the pool to deposit into */
        poolFee: Quantity;
        /** Optional receiver address */
        receiver?: Address;
    };
};
/**
 * Redeem from a CLMM position.
 */
type RedeemCLMMAction = {
    /** Protocol to redeem from */
    protocol: string;
    /** Action type */
    action: "redeemclmm";
    /** Action arguments */
    args: {
        /** Input token address to redeem */
        tokenIn: Address;
        /** Output token addresses to receive */
        tokenOut: Address[];
        /** Amount of liquidity to redeem */
        liquidity: ActionOutputReference<Quantity>;
        /** Token ID of the NFT position */
        tokenId: string;
        /** Optional receiver address */
        receiver?: Address;
    };
};
/**
 * Tokenized single deposit action.
 */
type TokenizedSingleDepositAction = {
    /** Protocol to deposit to */
    protocol: string;
    /** Action type */
    action: "tokenizedsingledeposit";
    /** Action arguments */
    args: {
        /** Input token address */
        tokenIn: Address;
        /** Output token address (required) */
        tokenOut: Address;
        /** Amount to deposit */
        amountIn: ActionOutputReference<Quantity>;
        /** Primary contract address */
        primaryAddress: Address;
        /** Optional receiver address */
        receiver?: Address;
    };
};
/**
 * Tokenized multi deposit action.
 */
type TokenizedMultiDepositAction = {
    /** Protocol to deposit to */
    protocol: string;
    /** Action type */
    action: "tokenizedmultideposit";
    /** Action arguments */
    args: {
        /** Input token addresses */
        tokenIn: Address[];
        /** Output token address (required) */
        tokenOut: Address;
        /** Amounts to deposit */
        amountIn: ActionOutputReference<Quantity>[];
        /** Primary contract address */
        primaryAddress: Address;
        /** Optional receiver address */
        receiver?: Address;
    };
};
/**
 * Tokenized single redeem action.
 */
type TokenizedSingleRedeemAction = {
    /** Protocol to redeem from */
    protocol: string;
    /** Action type */
    action: "tokenizedsingleredeem";
    /** Action arguments */
    args: {
        /** Input token address */
        tokenIn: Address;
        /** Output token address */
        tokenOut: Address;
        /** Amount to redeem */
        amountIn: ActionOutputReference<Quantity>;
        /** Primary contract address */
        primaryAddress: Address;
        /** Optional receiver address */
        receiver?: Address;
    };
};
/**
 * Tokenized multi redeem action.
 */
type TokenizedMultiRedeemAction = {
    /** Protocol to redeem from */
    protocol: string;
    /** Action type */
    action: "tokenizedmultiredeem";
    /** Action arguments */
    args: {
        /** Input token address */
        tokenIn: Address;
        /** Output token addresses */
        tokenOut: Address[];
        /** Amount to redeem */
        amountIn: ActionOutputReference<Quantity>;
        /** Primary contract address */
        primaryAddress: Address;
        /** Optional receiver address */
        receiver?: Address;
    };
};
/**
 *  Transfer tokens to another address.
 */
type TransferAction = {
    /** Protocol to use for transfer */
    protocol: string;
    /** Action type */
    action: "transfer";
    /** Action arguments */
    args: {
        /** Token to transfer */
        token: Address;
        /** Amount to transfer in wei (with full decimals) */
        amount: ActionOutputReference<Quantity>;
        /** Address to transfer to */
        receiver: Address;
        /** Optional ERC721 or ERC1155 token ID */
        id?: string;
    };
};
/**
 * Transfer tokens from another address.
 */
type TransferFromAction = {
    /** Action type */
    action: "transferfrom";
    /** Protocol to use */
    protocol: string;
    /** Action arguments */
    args: {
        /** Token to transfer */
        token: Address;
        /** Address to transfer from */
        sender: Address;
        /** Address to transfer to */
        receiver: Address;
        /** Amount to transfer */
        amount: ActionOutputReference<Quantity>;
        /** Optional ERC721 or ERC1155 token ID */
        id?: string;
    };
};
/**
 * Single deposit action (deprecated, use `deposit` instead).
 */
type SingleDepositAction = {
    /** Protocol to deposit to */
    protocol: string;
    /** Action type */
    action: "singledeposit";
    /** Action arguments */
    args: {
        /** Input token address */
        tokenIn: Address;
        /** Output token address (optional) */
        tokenOut?: Address;
        /** Amount to deposit */
        amountIn: ActionOutputReference<Quantity>;
        /** Primary contract address */
        primaryAddress: Address;
        /** Optional receiver address */
        receiver?: Address;
    };
};
/**
 * Multi deposit action (deprecated, use `deposit` instead).
 */
type MultiDepositAction = {
    /** Protocol to deposit to */
    protocol: string;
    /** Action type */
    action: "multideposit";
    /** Action arguments */
    args: {
        /** Input token addresses */
        tokenIn: Address[];
        /** Output token address (optional) */
        tokenOut?: Address;
        /** Amounts to deposit */
        amountIn: ActionOutputReference<Quantity>[];
        /** Primary contract address */
        primaryAddress: Address;
        /** Optional receiver address */
        receiver?: Address;
    };
};
/**
 * Single redeem action (deprecated, use `redeem` instead).
 */
type SingleRedeemAction = {
    /** Protocol to redeem from */
    protocol: string;
    /** Action type */
    action: "singleredeem";
    /** Action arguments */
    args: {
        /** Input token address (optional) */
        tokenIn?: Address;
        /** Output token address */
        tokenOut: Address;
        /** Amount to redeem */
        amountIn: ActionOutputReference<Quantity>;
        /** Primary contract address */
        primaryAddress: Address;
        /** Optional receiver address */
        receiver?: Address;
    };
};
/**
 * Multi redeem action (deprecated, use `redeem` instead).
 */
type MultiRedeemAction = {
    /** Protocol to redeem from */
    protocol: string;
    /** Action type */
    action: "multiredeem";
    /** Action arguments */
    args: {
        /** Input token address (optional) */
        tokenIn?: Address;
        /** Output token addresses */
        tokenOut: Address[];
        /** Amount to redeem */
        amountIn: ActionOutputReference<Quantity>;
        /** Primary contract address */
        primaryAddress: Address;
        /** Optional receiver address */
        receiver?: Address;
    };
};
/**
 * Multi-output single deposit action.
 */
type MultiOutSingleDepositAction = {
    /** Protocol to deposit to */
    protocol: string;
    /** Action type */
    action: "multioutsingledeposit";
    /** Action arguments */
    args: {
        /** Input token address */
        tokenIn: Address;
        /** Output token addresses */
        tokenOut: Address[];
        /** Amount to deposit */
        amountIn: ActionOutputReference<Quantity>;
        /** Primary contract address */
        primaryAddress: Address;
        /** Optional receiver address */
        receiver?: Address;
    };
};
/**
 *  Swap tokens action.
 */
type SwapAction = {
    /** Protocol for the swap */
    protocol: string;
    /** Action type */
    action: "swap";
    /** Action arguments */
    args: {
        /** Input token address */
        tokenIn: Address;
        /** Output token address */
        tokenOut: Address;
        /** Amount to swap in wei (with full decimals) */
        amountIn: ActionOutputReference<Quantity>;
        /** Address of the router or pool contract */
        primaryAddress?: Address;
        /** Address to receive the output tokens */
        receiver: Address;
        /** Slippage tolerance in basis points (100 = 1%) */
        slippage?: Quantity;
        /** Optional pool fee in basis points when using specific pools */
        poolFee?: Quantity;
    };
};
/**
 * Permit and transfer tokens from another address.
 */
type PermitTransferFromAction = {
    /** Protocol to use */
    protocol: string;
    /** Action type */
    action: "permittransferfrom";
    /** Action arguments */
    args: {
        /** Token(s) to transfer */
        token: Address | Address[];
        /** Amount(s) to transfer */
        amount: ActionOutputReference<Quantity> | ActionOutputReference<Quantity>[];
        /** Address to transfer from */
        sender: Address;
        /** Address to transfer to */
        receiver: Address;
        /** Nonce value to prevent signature replay */
        nonce: Quantity;
        /** Timestamp after which the signature is invalid */
        deadline: Quantity;
        /** The EIP-2612 permit signature */
        signature: BytesArg;
    };
};
/**
 * Union type of all possible bundle actions.
 */
type BundleAction = DepositAction | DepositCLMMAction | RouteAction | BridgeAction | BalanceAction | TransferAction | RedeemAction | ApproveAction | BorrowAction | SingleDepositAction | MultiDepositAction | TokenizedSingleDepositAction | TokenizedMultiDepositAction | MultiOutSingleDepositAction | HarvestAction | PermitTransferFromAction | SingleRedeemAction | MultiRedeemAction | TokenizedSingleRedeemAction | TokenizedMultiRedeemAction | RedeemCLMMAction | RepayAction | SwapAction | TransferFromAction | CallAction | SplitAction | MergeAction | MinAmountOutAction | SlippageAction | FeeAction | EnsoFeeAction;

/**
 * @fileoverview Type definitions for the Enso Finance API SDK
 */

/**
 * Represents the different routing strategies available for transactions.
 * {@link https://docs.enso.build/pages/build/reference/routing-strategies}
 */
type RoutingStrategy = "router" | "delegate" | "router-legacy" | "delegate-legacy";
type TokenType = "defi" | "base";
/**
 * Ethereum address format - must be a 42-character hexadecimal string starting with '0x'.
 * @example '0x123456789abcdef123456789abcdef1234567890'
 */
type Address = `0x${string}`;
type Quantity = string | number;
type BytesArg = `0x${string}`;
/**
 * Can be a single address or an array of addresses.
 */
type MultiAddress = Address | Address[];
/**
 * Standard transaction object returned by the API.
 */
type Transaction = {
    /** Raw transaction data in hexadecimal format */
    data: string;
    /** Address of the recipient for the transaction - an [Enso contract](https://docs.enso.build/pages/build/reference/deployments)
     * determined by the routing strategy you used in the request
     * @see {@link RoutingStrategy}
     */
    to: Address;
    /** Sender address */
    from: Address;
    /** Value to send in wei */
    value: Quantity;
};
/**
 * Parameters for getting route data between two tokens.
 */
type RouteParams = {
    /** Ethereum address of the wallet to send the transaction from */
    fromAddress: Address;
    /** Ethereum address of the receiver of the tokenOut */
    receiver?: Address;
    /** Ethereum address of the spender of the tokenIn */
    spender?: Address;
    /** Chain ID of the network to execute the transaction on */
    chainId: number;
    /** Chain ID of the destination network for cross-chain bridging */
    destinationChainId?: number;
    /** Amount of tokenIn to swap in wei */
    amountIn: Quantity[];
    /** Slippage in basis points (1/10000). If specified, minAmountOut should not be specified */
    slippage?: Quantity;
    /** Minimum amount out in wei. If specified, slippage should not be specified */
    minAmountOut?: Quantity[];
    /** Ethereum address of the token to swap from. For ETH, use 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee */
    tokenIn: Address[];
    /** Ethereum address of the token to swap to. For ETH, use 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee */
    tokenOut: Address[];
    /** Routing strategy to use */
    routingStrategy: RoutingStrategy;
    /** Fee in basis points (1/10000) for each amountIn value. Must be in range 0-100 */
    fee?: Quantity[];
    /** The Ethereum address that will receive the collected fee. Required if fee is provided */
    feeReceiver?: Address;
    /** A list of swap aggregators to be ignored from consideration */
    ignoreAggregators?: string[];
    /** A list of standards to be ignored from consideration */
    ignoreStandards?: string[];
    /** Flag that indicates if gained tokenOut should be sent to EOA (deprecated) */
    toEoa?: boolean;
    /** Referral code that will be included in an on-chain event */
    referralCode?: string;
};
/**
 * Represents a hop in the routing path.
 */
type Hop = {
    /** Input tokens for this hop */
    tokenIn: Address[];
    /** Output tokens for this hop */
    tokenOut: Address[];
    /** Protocol used for this hop */
    protocol: string;
    /** Action performed in this hop */
    action: string;
    /** Primary contract address */
    primary: Address;
    /** Internal routes used in this hop */
    internalRoutes: string[];
    /** Arguments for this hop */
    args: Record<string, any>;
    /** Chain ID of the network */
    chainId: number;
};
/**
 * Response data from route calculation.
 */
type RouteData = {
    /** Array of hops representing the calculated route */
    route: Hop[];
    /** Estimated gas used by the transaction */
    gas: Quantity;
    /** Estimated amount received */
    amountOut: Quantity;
    /** Price impact in basis points, null if USD price not found */
    priceImpact: Quantity | null;
    /** Block number the transaction was created on */
    createdAt: number;
    /** The tx object to use in ethers */
    tx: Transaction;
    /** Collected fee amounts for each amountIn input */
    feeAmount: Quantity[];
};
/**
 * Parameters for getting approval data.
 */
type ApproveParams = {
    /** Ethereum address of the wallet to send the transaction from */
    fromAddress: Address;
    /** ERC20 token address of the token to approve */
    tokenAddress: Address;
    /** Chain ID of the network to execute the transaction on */
    chainId: number;
    /** Amount of tokens to approve in wei */
    amount: Quantity;
};
/**
 * Response data from approval request.
 */
type ApproveData = {
    /** Amount of tokens approved in wei */
    amount: Quantity;
    /** Gas estimate for the transaction */
    gas: Quantity;
    /** Address that is allowed to spend the tokens */
    spender: Address;
    /** Token address that was approved */
    token: Address;
    /** Transaction data */
    tx: Transaction;
};
/**
 * Represents wallet balance information.
 */
type WalletBalance = {
    /** The unformatted balance of the token */
    amount: Quantity;
    /** The number of decimals the token uses */
    decimals: number;
    /** The address of the token */
    token: Address;
    /** Price of the token in USD */
    price: Quantity;
    /** Name of the token */
    name: string;
    /** Symbol of the token */
    symbol: string;
    /** Logo URI of the token */
    logoUri: string;
};
/**
 * Parameters for getting wallet balances.
 */
type BalanceParams = {
    /** Chain ID of the network to execute the transaction on */
    chainId?: number;
    /** Address of the eoa with which to associate the ensoWallet for balances */
    eoaAddress: Address;
    /** If true returns balances for the provided eoaAddress, instead of the associated ensoWallet */
    useEoa?: boolean;
};
/**
 * Parameters for querying token data.
 */
interface TokenParams {
    /** The overarching project or platform associated with the DeFi token */
    project?: string;
    /** The specific standard integration or version of the DeFi project */
    protocolSlug?: string;
    /** Underlying tokens of defi token */
    underlyingTokens?: MultiAddress;
    /** Exact composition of underlying tokens of defi token */
    underlyingTokensExact?: MultiAddress;
    /** Ethereum addresses for contract interaction of defi tokens */
    primaryAddress?: MultiAddress;
    /** Ethereum addresses of the tokens */
    address?: MultiAddress;
    /** Chain ID of the network of the token */
    chainId?: number;
    /** Type of token. If not provided, both types will be taken into account */
    type?: TokenType;
    /** Only include tokens with APY over this value */
    apyFrom?: Quantity;
    /** Only include tokens with APY below this value */
    apyTo?: Quantity;
    /** Only include tokens with TVL over this value */
    tvlFrom?: Quantity;
    /** Only include tokens with TVL below this value */
    tvlTo?: Quantity;
    /** Pagination page number. Pages are of length 1000 */
    page?: number;
    /** Cursor for pagination. Pages are of length 1000 */
    cursor?: number;
    /** Whether to include token metadata (symbol, name and logos) */
    includeMetadata?: boolean;
    /** Names of the tokens */
    name?: string[];
    /** Symbols of the tokens */
    symbol?: string[];
}
/**
 * Represents an underlying token in a tokenized position.
 */
interface UnderlyingToken {
    /** Ethereum address of the token */
    address: Address;
    /** Chain ID of the network of the token */
    chainId: number;
    /** Type of token */
    type: TokenType;
    /** Token decimals */
    decimals: number;
    /** Token symbol */
    symbol: string | null;
    /** Token name */
    name: string | null;
    /** A list of logos for the token */
    logosUri: string[] | null;
}
/**
 * Base token information.
 */
interface Token {
    /** Ethereum address of the token */
    address: Address;
    /** Chain ID of the network of the token */
    chainId: number;
    /** Type of token */
    type: "defi" | "base";
    /** Token decimals */
    decimals: number;
    /** Token symbol */
    symbol: string | null;
    /** Token name */
    name: string | null;
    /** A list of logos for the token */
    logosUri: string[] | null;
    /** Underlying tokens of defi token */
    underlyingTokens: UnderlyingToken[] | null;
    /** The overarching project or platform associated with the DeFi token */
    project: string | null;
    /** The specific standard integration or version of the DeFi project */
    protocolSlug: string | null;
    /** The defi position APY */
    apy: Quantity | null;
    /** The defi position base APY */
    apyBase: Quantity | null;
    /** The defi position reward APY */
    apyReward: Quantity | null;
    /** The defi position TVL */
    tvl: Quantity | null;
    /** Ethereum address for contract interaction of defi token */
    primaryAddress: Address | null;
}
/**
 * Extended token data type.
 */
type TokenData = Token & {
    /** The overarching project or platform associated with the DeFi token */
    project: string | null;
    /** The specific standard integration or version of the DeFi project */
    protocolSlug: string | null;
    /** Underlying tokens of defi token */
    underlyingTokens: Token[] | null;
    /** Ethereum address for contract interaction of defi token */
    primaryAddress: Address | null;
    /** The defi position APY */
    apy: Quantity | null;
    /** The defi position TVL */
    tvl: Quantity | null;
};
type PaginatedTokenData = PaginatedResult & {
    /** Array of token data */
    data: TokenData[];
};
/**
 * Paginated non-tokenized response.
 */
interface PaginatedNonTokenizedPositionData extends PaginatedResult {
    /** Returned data for current page */
    data: NonTokenizedPositionData[];
}
/**
 * Parameters for getting token price data.
 */
type PriceParams = {
    /** Chain ID of the network to search for */
    chainId: number;
    /** Address of the token to search for */
    address: Address;
};
/**
 * Parameters for getting multiple token prices.
 */
type MultiPriceParams = {
    /** Chain ID of the network to search for */
    chainId: number;
    /** Addresses of tokens to check prices for */
    addresses: Address[];
};
/**
 * Token price data response.
 */
type PriceData = {
    /** Token price in USD */
    price: Quantity;
    /** Token address */
    address: Address;
    /** Token decimals */
    decimals: number;
    /** Token symbol */
    symbol: string;
    /** Unix timestamp of the price */
    timestamp: number;
    /** Chain ID of the token */
    chainId: number;
    /** Confidence level of the price (0-1) */
    confidence: number;
};
/**
 * Parameters for querying protocol data.
 */
type ProtocolParams = {
    /** Chain ID of the network to search for */
    chainId?: number | string;
    /** Slug of the project to search for */
    slug?: string;
};
/**
 * Protocol information.
 */
type ProtocolData = {
    /** Protocol project (category) */
    project: string | null;
    /** Protocol slug identifier */
    slug: string;
    /** Protocol name */
    name: string | null;
    /** Protocol description */
    description: string | null;
    /** Protocol website URL */
    url: string | null;
    /** Protocol logo URIs */
    logosUri: string[] | null;
    /** Supported chains for this protocol */
    chains: Network[] | null;
};
/**
 * Parameters for bundle creation.
 */
type BundleParams = {
    /** Chain ID of the network to execute the transaction on */
    chainId: number;
    /** Ethereum address of the wallet to send the transaction from */
    fromAddress: Address;
    /** Routing strategy to use */
    routingStrategy: RoutingStrategy;
    /** Ethereum address of the receiver of the tokenOut */
    receiver?: Address;
    /** Ethereum address of the spender of the tokenIn */
    spender?: Address;
    /** A list of swap aggregators to be ignored from consideration */
    ignoreAggregators?: string[];
    /** Referral code that will be included in an on-chain event */
    referralCode?: string;
    /** A list of standards to be ignored from consideration */
    ignoreStandards?: string[] | null;
};
/**
 * Bundle transaction data response.
 */
type BundleData = {
    /** Array of actions in the bundle */
    bundle: BundleAction[];
    /** Gas estimate for the bundle */
    gas: Quantity;
    /** Block number the transaction was created on */
    createdAt: number;
    /** The tx object to use in ethers */
    tx: Transaction;
    /** Amounts out for each action */
    amountsOut: Record<Address, Quantity>;
    route?: Hop[];
};
/**
 * Network information.
 */
interface Network {
    /** Network ID */
    id: number;
    /** Network name */
    name: string | null;
}
/**
 * Connected network information.
 */
interface ConnectedNetwork {
    /** Network ID */
    id: number;
    /** Network name */
    name: string | null;
    /** Whether the network is connected */
    isConnected: boolean;
}
/**
 * Project information.
 */
interface Project {
    /** Project identifier */
    id: string;
    /** Supported chains for the project */
    chains: number[];
    /** Protocols supported in the project */
    protocols: string[];
}
/**
 * Standard protocol data.
 */
interface StandardData {
    /** Protocol information */
    protocol: {
        /** Protocol slug */
        slug: string;
        /** Protocol URL */
        url: string;
    };
    /** Forked protocols */
    forks: {
        /** Fork slug */
        slug: string;
        /** Fork URL */
        url: string;
    }[];
    /** Supported actions */
    actions: StandardAction[];
}
/**
 * Standard action definition.
 */
interface StandardAction {
    /** Action identifier */
    action: string;
    /** Action name */
    name: string | null;
    /** Function names used in contracts */
    functionNames: string[];
    /** Supported chains for this action */
    supportedChains: Network[];
    /** Required inputs for this action */
    inputs: string[];
}
/**
 * Action data definition.
 */
interface ActionData {
    /** Action identifier */
    action: string;
    /** Input parameter definitions */
    inputs: {
        [key: string]: {
            type: string;
            description: string;
            optional?: boolean;
        };
    };
}
/**
 * IPOR shortcut input data.
 */
interface IporShortcutInputData {
    /** Flag that indicates whether to use the shared router */
    isRouter?: boolean | null;
    /** Amount of tokenIn in wei */
    amountIn: Quantity;
    /** Address of the tokenIn */
    tokenIn: Address;
    /** Address of the tokenBToBuy */
    tokenBToBuy: Address;
    /** Percentage of tokenB to buy in basis points */
    percentageForTokenB: Quantity;
    /** Slippage in basis points */
    slippage?: Quantity;
    /** Flag that indicates whether to simulate the transaction */
    simulate?: boolean;
}
/**
 * IPOR shortcut transaction data.
 */
interface IporShortcutData {
    /** Block number the transaction was created on */
    createdAt: number;
    /** The tx object to use in ethers */
    tx: Transaction;
    /** Logs from the simulated transaction */
    logs: string[];
    /** Tenderly simulation URL */
    simulationURL: string;
    route?: Hop[];
}
/**
 * Non-tokenized position data.
 */
interface NonTokenizedPositionData {
    /** Chain ID of the network of the nontokenized position */
    chainId: number;
    /** The specific standard integration or version of the nontokenized position */
    protocol: string;
    /** Ethereum address of the nontokenized position */
    address: Address;
    /** Ethereum address of the nontokenized position */
    primaryAddress: Address | null;
    /** Underlying tokens of nontokenized position */
    underlyingTokens: Token[] | null;
}
/**
 * Parameters for querying non-tokenized positions.
 */
interface NonTokenizedParams {
    /** The overarching project or platform associated with the DeFi position */
    project?: string;
    /** The specific standard integration or version of the DeFi project */
    protocolSlug?: string;
    /** Chain ID of the network of the nontokenized position */
    chainId?: number;
    /** Chain ID of the destination network for cross-chain bridging */
    destinationChainId?: number;
    /** Ethereum addresses of the nontokenized positions */
    address?: Address[];
    /** Ethereum addresses for contract interaction of nontokenized position */
    primaryAddress?: Address[];
    /** Pagination page number. Pages are of length 1000 */
    page?: number;
    /** Cursor for pagination. Pages are of length 1000 */
    cursor?: number;
}
/**
 * Parameters for routing to non-tokenized position.
 */
interface RouteNonTokenizedParams {
    /** Chain ID of the network to execute the transaction on */
    chainId: number;
    /** Ethereum address of the wallet to send the transaction from */
    fromAddress: Address;
    /** Routing strategy to use (must be 'delegate') */
    routingStrategy: "delegate" | "delegate-legacy";
    /** Input tokens */
    tokenIn: Address[];
    /** Non-tokenized position to receive */
    positionOut: Address;
    /** Slippage in basis points */
    slippage?: Quantity;
    /** Fee in basis points */
    fee?: Quantity[];
    /** Fee receiver address */
    feeReceiver?: Address;
    /** Amount to send */
    amountIn: Quantity[];
    /** Receiver address */
    receiver: Address;
    /** Spender address */
    spender?: Address;
    /** Referral code that will be included in an on-chain event */
    referralCode?: string;
}
/**
 * Parameters for network queries.
 */
interface NetworkParams {
    /** Name of the network to search for */
    name?: string;
    /** Chain ID of the network to search for */
    chainId?: string;
}
/**
 * Pagination metadata.
 */
interface PaginationMeta {
    /** Total amount of pages */
    total: number;
    /** Last page number */
    lastPage: number;
    /** Current page number */
    currentPage: number;
    /** Amount of elements per page */
    perPage: number;
    /** Previous page */
    prev: number | null;
    /** Next page */
    next: number | null;
    /** Cursor for pagination */
    cursor: number;
}
/**
 * Base paginated result type.
 */
interface PaginatedResult {
    /** Metadata for pagination */
    meta: PaginationMeta;
}

/**
 * EnsoClient class for interacting with the Enso Finance API.
 *
 * This client provides methods to interact with various Enso Finance endpoints for
 * token routing, bundling, approvals, and more.
 *
 * @example
 * const client = new EnsoClient({
 *   apiKey: 'your-api-key',
 *   baseURL: 'https://api.enso.finance/api/v1'
 * });
 */
declare class EnsoClient {
    private client;
    /**
     * Creates an instance of EnsoClient.
     *
     * @param {Object} config - Configuration object
     * @param {string} config.apiKey - API key for authentication (required)
     * @param {string} [config.baseURL] - Base URL for the API (optional, defaults to production URL)
     */
    constructor({ baseURL, apiKey, }: {
        baseURL?: string;
        apiKey: string;
    });
    /**
     * Makes an HTTP request to the API.
     * @private
     * @template T - The expected response type
     * @param {AxiosRequestConfig} config - Axios request configuration
     * @returns {Promise<T>} The response data
     * @throws {Error} When the API request fails
     */
    private request;
    /**
     * Gets approval data to spend a token from an EOA wallet.
     *
     * Returns a transaction that approves your EOA wallet to spend the given amount of specified tokens.
     *
     * @param {ApproveParams} params - Parameters for the approval request
     * @returns {Promise<ApproveData>} Approval transaction data
     * @throws {Error} If the API request fails
     *
     * @example
     * const approval = await client.getApprovalData({
     *   fromAddress: '0x123...',
     *   tokenAddress: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48', // USDC
     *   chainId: 1,
     *   amount: '1000000000'
     * });
     */
    getApprovalData(params: ApproveParams): Promise<ApproveData>;
    /**
     * Gets execution data for the best route from a token to another.
     *
     * Calculates optimal transaction with the best route between two tokens, which may involve
     * several actions that interact with various DeFi protocols.
     *
     * @param {RouteParams} params - Parameters for the route request
     * @returns {Promise<RouteData>} Route execution data
     * @throws {Error} If the API request fails
     *
     * @example
     * const route = await client.getRouteData({
     *   fromAddress: '0x123...',
     *   receiver: '0x456...',
     *   spender: '0x789...',
     *   chainId: 1,
     *   amountIn: ['1000000000'],
     *   tokenIn: ['0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'], // USDC
     *   tokenOut: ['0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2'], // WETH
     *   slippage: '50', // 0.5%
     *   referralCode: '0123456789ABCDEF'
     * });
     */
    getRouteData(params: RouteParams): Promise<RouteData>;
    /**
     * Gets wallet balances per chain.
     *
     * Returns tokens balances for Enso Wallet associated with the given address.
     * With `useEoa` set to true, it returns balances for the given EOA address instead.
     *
     * @param {BalanceParams} params - Parameters for the balance request
     * @returns {Promise<WalletBalance[]>} Array of wallet balances
     * @throws {Error} If the API request fails
     *
     * @example
     * const balances = await client.getBalances({
     *   chainId: 1,
     *   eoaAddress: '0x123...',
     *   useEoa: true
     * });
     */
    getBalances(params: BalanceParams): Promise<WalletBalance[]>;
    /**
     * Gets token data by address.
     *
     * Returns tokens and their details with pagination.
     *
     * @param {TokenParams} params - Parameters for the token query
     * @returns {Promise<PaginatedTokenData>} Paginated token data
     * @throws {Error} If the API request fails
     *
     * @example
     * const tokens = await client.getTokenData({
     *   chainId: 1,
     *   type: 'defi',
     *   includeMetadata: true
     * });
     */
    getTokenData(params: TokenParams): Promise<PaginatedTokenData>;
    /**
     * Gets token price data.
     *
     * Returns token price for the given address and chainId.
     *
     * @param {PriceParams} params - Parameters for the price query
     * @returns {Promise<PriceData>} Token price data
     * @throws {Error} If the API request fails
     *
     * @example
     * const price = await client.getPriceData({
     *   chainId: 1,
     *   address: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2' // WETH
     * });
     */
    getPriceData(params: PriceParams): Promise<PriceData>;
    /**
     * Gets price data for multiple tokens.
     *
     * Returns prices for multiple tokens for the given chainId.
     *
     * @param {MultiPriceParams} params - Parameters for the multiple price query
     * @returns {Promise<PriceData[]>} Array of token price data
     * @throws {Error} If the API request fails
     *
     * @example
     * const prices = await client.getMultiplePriceData({
     *   chainId: 1,
     *   addresses: [
     *     '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2', // WETH
     *     '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'  // USDC
     *   ]
     * });
     */
    getMultiplePriceData(params: MultiPriceParams): Promise<PriceData[]>;
    /**
     * Gets protocol data.
     *
     * Returns all available protocols with supported chains.
     *
     * @param {ProtocolParams} [params] - Optional parameters for filtering protocols
     * @returns {Promise<ProtocolData[]>} Array of protocol data
     * @throws {Error} If the API request fails
     *
     * @example
     * const protocols = await client.getProtocolData({ chainId: 1 });
     */
    getProtocolData(params?: ProtocolParams): Promise<ProtocolData[]>;
    /**
     * Constructs bundled transaction data.
     *
     * Returns a single transaction bundling the submitted actions. For available actions, see `/actions` endpoint.
     *
     * @param {BundleParams} params - Parameters for the bundle request
     * @param {BundleAction[]} actions - Array of actions to bundle
     * @returns {Promise<BundleData>} Bundled transaction data
     * @throws {Error} If the API request fails
     *
     * @example
     * const bundle = await client.getBundleData(
     *   {
     *     chainId: 1,
     *     fromAddress: '0x123...',
     *     routingStrategy: 'delegate',
     *     referralCode: '0123456789ABCDEF'
     *   },
     *   [
     *     {
     *       protocol: ['enso'],
     *       action: 'route',
     *       args: {
     *         tokenIn: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',
     *         tokenOut: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',
     *         amountIn: '1000000000',
     *         receiver: '0x123...'
     *       }
     *     }
     *   ]
     * );
     */
    getBundleData(params: BundleParams, actions: BundleAction[]): Promise<BundleData>;
    /**
     * Gets execution data for best route to non-tokenized position.
     *
     * Calculates optimal transaction with the best route entering a non-tokenized position,
     * which may involve several actions that interact with various DeFi protocols.
     *
     * @param {RouteNonTokenizedParams} params - Parameters for the non-tokenized route request
     * @returns {Promise<RouteData>} Route execution data
     * @throws {Error} If the API request fails
     *
     * @example
     * const route = await client.getRouteNonTokenized({
     *   fromAddress: '0x123...',
     *   tokenIn: ['0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'],
     *   positionOut: '0xPositionAddress',
     *   amountIn: ['1000000000'],
     *   receiver: '0x123...',
     *   slippage: '50', // 0.5%
     *   referralCode: '0123456789ABCDEF'
     * });
     */
    getRouteNonTokenized(params: RouteNonTokenizedParams): Promise<RouteData>;
    /**
     * Gets IPOR shortcut transaction.
     *
     * Returns a transaction for IPOR shortcut operations.
     *
     * @param {Object} params - Parameters for the IPOR shortcut
     * @param {number} [params.chainId] - Chain ID (optional)
     * @param {string} params.fromAddress - Ethereum address of the wallet
     * @param {IporShortcutInputData} data - IPOR shortcut input data
     * @returns {Promise<IporShortcutData>} IPOR shortcut transaction data
     * @throws {Error} If the API request fails
     */
    getIporShortcut(params: {
        chainId?: number;
        fromAddress: string;
    }, data: IporShortcutInputData): Promise<IporShortcutData>;
    /**
     * Gets all standards.
     *
     * Returns standards available for bundling. Each element represents a protocol, with list of supported actions and chains the standard's supported on.
     *
     * @returns {Promise<StandardData[]>} Array of standard data
     * @throws {Error} If the API request fails
     */
    getStandards(): Promise<StandardData[]>;
    /**
     * Gets standard by protocol slug.
     *
     * Returns a standard matching the given `slug`, containing supported actions, exact `inputs`, and a list of chains the standard's supported on.
     *
     * @param {string} slug - The protocol slug
     * @returns {Promise<StandardData[]>} Array of standard data
     * @throws {Error} If the API request fails
     */
    getStandardBySlug(slug: string): Promise<StandardData[]>;
    /**
     * Gets all supported actions.
     *
     * Returns actions that can be bundled with `/shortcuts/bundle` endpoint. For specific protocol actions and exact action inputs, see `/actions/{slug}` endpoint.
     *
     * @returns {Promise<ActionData[]>} Array of action data
     * @throws {Error} If the API request fails
     */
    getActions(): Promise<ActionData[]>;
    /**
     * Gets actions for a specific protocol.
     *
     * @param {string} slug - The protocol slug
     * @returns {Promise<ActionData[]>} Array of action data for the protocol
     * @throws {Error} If the API request fails
     */
    getActionsBySlug(slug: string): Promise<ActionData[]>;
    /**
     * Gets all non-tokenized positions.
     *
     * Returns a list of all nontokenized positions with details.
     *
     * @param {NonTokenizedParams} [params] - Optional parameters for filtering
     * @returns {Promise<PaginatedNonTokenizedPositionData>} Paginated non-tokenized position data
     * @throws {Error} If the API request fails
     */
    getNonTokenizedPositions(params?: NonTokenizedParams): Promise<PaginatedNonTokenizedPositionData>;
    /**
     * Gets supported projects.
     *
     * Returns supported projects (e.g. `aave`) or platforms associated with available projects.
     *
     * @returns {Promise<Project[]>} Array of project data
     * @throws {Error} If the API request fails
     */
    getProjects(): Promise<Project[]>;
    /**
     * Gets protocols within a project.
     *
     * Returns all protocols available within the given project. For supported projects, see the `/projects` endpoint.
     *
     * @param {string} project - The project name
     * @returns {Promise<ProtocolData[]>} Array of protocol data within the project
     * @throws {Error} If the API request fails
     */
    getProtocolsByProject(project: string): Promise<ProtocolData[]>;
    /**
     * Gets supported networks.
     *
     * Returns networks supported by Enso.
     *
     * @param {NetworkParams} [params] - Optional parameters for filtering networks
     * @returns {Promise<ConnectedNetwork[]>} Array of network data
     * @throws {Error} If the API request fails
     */
    getNetworks(params?: NetworkParams): Promise<ConnectedNetwork[]>;
    /**
     * Gets supported aggregators.
     *
     * Fetches aggregators supported by Enso.
     *
     * @param {number} [chainId] - Chain ID to filter aggregators for
     * @returns {Promise<string[]>} Array of aggregator names
     * @throws {Error} If the API request fails
     */
    getAggregators(chainId?: number): Promise<string[]>;
    /**
     * Gets volume data for a chain.
     *
     * Returns total USD and transactions volume for the given chainId.
     *
     * @param {number} chainId - Chain ID to get volume for
     * @returns {Promise<unknown>} Volume data
     * @throws {Error} If the API request fails
     */
    getVolume(chainId: number): Promise<unknown>;
    getAccountId(): Promise<string>;
}

export { type ActionData, type Address, type ApproveData, type ApproveParams, type BalanceParams, type BundleAction, type BundleData, type BundleParams, type ConnectedNetwork, EnsoClient, type IporShortcutData, type IporShortcutInputData, type MultiPriceParams, type Network, type NonTokenizedPositionData, type PriceData, type PriceParams, type Project, type ProtocolData, type ProtocolParams, type RouteData, type RouteParams, type RoutingStrategy, type StandardAction, type StandardData, type TokenData, type TokenParams, type WalletBalance };
