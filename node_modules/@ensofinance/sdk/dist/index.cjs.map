{"version":3,"sources":["../src/index.ts","../src/client.ts"],"sourcesContent":["// src/index.ts - Client implementation updates to match OpenAPI specification\nimport {\n  ActionData,\n  Address,\n  ApproveData,\n  ApproveParams,\n  BalanceParams,\n  BundleAction,\n  BundleData,\n  BundleParams,\n  ConnectedNetwork,\n  IporShortcutData,\n  IporShortcutInputData,\n  MultiPriceParams,\n  Network,\n  NonTokenizedPositionData,\n  PriceData,\n  PriceParams,\n  Project,\n  ProtocolData,\n  ProtocolParams,\n  RouteData,\n  RouteParams,\n  RoutingStrategy,\n  StandardAction,\n  StandardData,\n  TokenData,\n  TokenParams,\n  WalletBalance\n} from \"./types/types\";\n\nexport type {\n  ActionData, Address, ApproveData, ApproveParams, BalanceParams, BundleAction, BundleData, BundleParams, ConnectedNetwork, IporShortcutData, IporShortcutInputData, MultiPriceParams, Network, NonTokenizedPositionData, PriceData,\n  PriceParams, Project, ProtocolData,\n  ProtocolParams, RouteData, RouteParams, RoutingStrategy, StandardAction, StandardData, TokenData,\n  TokenParams, WalletBalance,\n};\n\nexport { EnsoClient } from \"./client\";","import axios, { AxiosError, AxiosInstance, AxiosRequestConfig } from \"axios\";\nimport {\n  ActionData,\n  ApproveData,\n  ApproveParams,\n  BalanceParams,\n  BundleAction,\n  BundleData,\n  BundleParams,\n  ConnectedNetwork,\n  IporShortcutData,\n  IporShortcutInputData,\n  MultiPriceParams,\n  NetworkParams,\n  NonTokenizedParams,\n  PaginatedNonTokenizedPositionData,\n  PaginatedTokenData,\n  PriceData,\n  PriceParams,\n  Project,\n  ProtocolData,\n  ProtocolParams,\n  RouteData,\n  RouteNonTokenizedParams,\n  RouteParams,\n  StandardData,\n  TokenParams,\n  WalletBalance,\n} from \"./types/types\";\n\nconst DEFAULT_BASE_URL = \"https://api.enso.finance/api/v1\";\n/**\n * EnsoClient class for interacting with the Enso Finance API.\n *\n * This client provides methods to interact with various Enso Finance endpoints for\n * token routing, bundling, approvals, and more.\n *\n * @example\n * const client = new EnsoClient({\n *   apiKey: 'your-api-key',\n *   baseURL: 'https://api.enso.finance/api/v1'\n * });\n */\nexport class EnsoClient {\n  private client: AxiosInstance;\n\n  /**\n   * Creates an instance of EnsoClient.\n   *\n   * @param {Object} config - Configuration object\n   * @param {string} config.apiKey - API key for authentication (required)\n   * @param {string} [config.baseURL] - Base URL for the API (optional, defaults to production URL)\n   */\n  constructor({\n    baseURL = DEFAULT_BASE_URL,\n    apiKey,\n  }: {\n    baseURL?: string;\n    apiKey: string;\n  }) {\n    this.client = axios.create({\n      baseURL,\n      headers: {\n        Authorization: `Bearer ${apiKey}`,\n      },\n    });\n  }\n\n  /**\n   * Makes an HTTP request to the API.\n   * @private\n   * @template T - The expected response type\n   * @param {AxiosRequestConfig} config - Axios request configuration\n   * @returns {Promise<T>} The response data\n   * @throws {Error} When the API request fails\n   */\n  private async request<T>(\n    config: AxiosRequestConfig,\n    retries = 3,\n  ): Promise<T> {\n    try {\n      const response = await this.client.request<T>(config);\n      return response.data;\n    } catch (error: any) {\n      if (error.response) {\n        // The request was made and the server responded with an error status\n        throw new EnsoApiError(\n          `API Error: ${error.response.data?.message || error.message}`,\n          error.response.status,\n          error.response.data,\n        );\n      } else if (error.request && retries > 0) {\n        // Network error - retry with backoff\n        const delay = 2 ** (3 - retries) * 1000;\n        await new Promise((resolve) => setTimeout(resolve, delay));\n        return this.request<T>(config, retries - 1);\n      } else {\n        throw new Error(`Request Error: ${error.message}`);\n      }\n    }\n  }\n\n  /**\n   * Gets approval data to spend a token from an EOA wallet.\n   *\n   * Returns a transaction that approves your EOA wallet to spend the given amount of specified tokens.\n   *\n   * @param {ApproveParams} params - Parameters for the approval request\n   * @returns {Promise<ApproveData>} Approval transaction data\n   * @throws {Error} If the API request fails\n   *\n   * @example\n   * const approval = await client.getApprovalData({\n   *   fromAddress: '0x123...',\n   *   tokenAddress: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48', // USDC\n   *   chainId: 1,\n   *   amount: '1000000000'\n   * });\n   */\n  public async getApprovalData(params: ApproveParams): Promise<ApproveData> {\n    const url = \"/wallet/approve\";\n\n    return this.request<ApproveData>({\n      url,\n      method: \"GET\",\n      params: { ...params, routingStrategy: \"router\" },\n    });\n  }\n\n  /**\n   * Gets execution data for the best route from a token to another.\n   *\n   * Calculates optimal transaction with the best route between two tokens, which may involve\n   * several actions that interact with various DeFi protocols.\n   *\n   * @param {RouteParams} params - Parameters for the route request\n   * @returns {Promise<RouteData>} Route execution data\n   * @throws {Error} If the API request fails\n   *\n   * @example\n   * const route = await client.getRouteData({\n   *   fromAddress: '0x123...',\n   *   receiver: '0x456...',\n   *   spender: '0x789...',\n   *   chainId: 1,\n   *   amountIn: ['1000000000'],\n   *   tokenIn: ['0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'], // USDC\n   *   tokenOut: ['0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2'], // WETH\n   *   slippage: '50', // 0.5%\n   *   referralCode: '0123456789ABCDEF'\n   * });\n   */\n  public async getRouteData(params: RouteParams): Promise<RouteData> {\n    const url = \"/shortcuts/route\";\n\n    return this.request<RouteData>({\n      method: \"GET\",\n      url,\n      params,\n    });\n  }\n\n  /**\n   * Gets wallet balances per chain.\n   *\n   * Returns tokens balances for Enso Wallet associated with the given address.\n   * With `useEoa` set to true, it returns balances for the given EOA address instead.\n   *\n   * @param {BalanceParams} params - Parameters for the balance request\n   * @returns {Promise<WalletBalance[]>} Array of wallet balances\n   * @throws {Error} If the API request fails\n   *\n   * @example\n   * const balances = await client.getBalances({\n   *   chainId: 1,\n   *   eoaAddress: '0x123...',\n   *   useEoa: true\n   * });\n   */\n  public async getBalances(params: BalanceParams): Promise<WalletBalance[]> {\n    const url = \"/wallet/balances\";\n\n    if (typeof params.useEoa === \"undefined\") {\n      params.useEoa = true;\n    }\n\n    return this.request<WalletBalance[]>({\n      method: \"GET\",\n      url,\n      params,\n    });\n  }\n\n  /**\n   * Gets token data by address.\n   *\n   * Returns tokens and their details with pagination.\n   *\n   * @param {TokenParams} params - Parameters for the token query\n   * @returns {Promise<PaginatedTokenData>} Paginated token data\n   * @throws {Error} If the API request fails\n   *\n   * @example\n   * const tokens = await client.getTokenData({\n   *   chainId: 1,\n   *   type: 'defi',\n   *   includeMetadata: true\n   * });\n   */\n  public async getTokenData(params: TokenParams): Promise<PaginatedTokenData> {\n    const url = `/tokens`;\n    if (!params.page) {\n      params.page = 1;\n    }\n\n    return this.request<PaginatedTokenData>({\n      method: \"GET\",\n      url,\n      params,\n    });\n  }\n\n  /**\n   * Gets token price data.\n   *\n   * Returns token price for the given address and chainId.\n   *\n   * @param {PriceParams} params - Parameters for the price query\n   * @returns {Promise<PriceData>} Token price data\n   * @throws {Error} If the API request fails\n   *\n   * @example\n   * const price = await client.getPriceData({\n   *   chainId: 1,\n   *   address: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2' // WETH\n   * });\n   */\n  public async getPriceData(params: PriceParams): Promise<PriceData> {\n    const url = `/prices/${params.chainId}/${params.address}`;\n\n    return this.request<PriceData>({\n      method: \"GET\",\n      url,\n    });\n  }\n\n  /**\n   * Gets price data for multiple tokens.\n   *\n   * Returns prices for multiple tokens for the given chainId.\n   *\n   * @param {MultiPriceParams} params - Parameters for the multiple price query\n   * @returns {Promise<PriceData[]>} Array of token price data\n   * @throws {Error} If the API request fails\n   *\n   * @example\n   * const prices = await client.getMultiplePriceData({\n   *   chainId: 1,\n   *   addresses: [\n   *     '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2', // WETH\n   *     '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'  // USDC\n   *   ]\n   * });\n   */\n  public async getMultiplePriceData(\n    params: MultiPriceParams,\n  ): Promise<PriceData[]> {\n    const url = `/prices/${params.chainId}`;\n\n    return this.request<PriceData[]>({\n      method: \"GET\",\n      url,\n      params: { addresses: params.addresses },\n    });\n  }\n\n  /**\n   * Gets protocol data.\n   *\n   * Returns all available protocols with supported chains.\n   *\n   * @param {ProtocolParams} [params] - Optional parameters for filtering protocols\n   * @returns {Promise<ProtocolData[]>} Array of protocol data\n   * @throws {Error} If the API request fails\n   *\n   * @example\n   * const protocols = await client.getProtocolData({ chainId: 1 });\n   */\n  public async getProtocolData(\n    params?: ProtocolParams,\n  ): Promise<ProtocolData[]> {\n    const url = `/protocols`;\n\n    return this.request<ProtocolData[]>({\n      method: \"GET\",\n      url,\n      params,\n    });\n  }\n\n  /**\n   * Constructs bundled transaction data.\n   *\n   * Returns a single transaction bundling the submitted actions. For available actions, see `/actions` endpoint.\n   *\n   * @param {BundleParams} params - Parameters for the bundle request\n   * @param {BundleAction[]} actions - Array of actions to bundle\n   * @returns {Promise<BundleData>} Bundled transaction data\n   * @throws {Error} If the API request fails\n   *\n   * @example\n   * const bundle = await client.getBundleData(\n   *   {\n   *     chainId: 1,\n   *     fromAddress: '0x123...',\n   *     routingStrategy: 'delegate',\n   *     referralCode: '0123456789ABCDEF'\n   *   },\n   *   [\n   *     {\n   *       protocol: ['enso'],\n   *       action: 'route',\n   *       args: {\n   *         tokenIn: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',\n   *         tokenOut: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',\n   *         amountIn: '1000000000',\n   *         receiver: '0x123...'\n   *       }\n   *     }\n   *   ]\n   * );\n   */\n  public async getBundleData(\n    params: BundleParams,\n    actions: BundleAction[],\n  ): Promise<BundleData> {\n    const url = \"/shortcuts/bundle\";\n\n    return this.request<BundleData>({\n      method: \"POST\",\n      url,\n      params,\n      data: actions,\n    });\n  }\n\n  /**\n   * Gets execution data for best route to non-tokenized position.\n   *\n   * Calculates optimal transaction with the best route entering a non-tokenized position,\n   * which may involve several actions that interact with various DeFi protocols.\n   *\n   * @param {RouteNonTokenizedParams} params - Parameters for the non-tokenized route request\n   * @returns {Promise<RouteData>} Route execution data\n   * @throws {Error} If the API request fails\n   *\n   * @example\n   * const route = await client.getRouteNonTokenized({\n   *   fromAddress: '0x123...',\n   *   tokenIn: ['0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'],\n   *   positionOut: '0xPositionAddress',\n   *   amountIn: ['1000000000'],\n   *   receiver: '0x123...',\n   *   slippage: '50', // 0.5%\n   *   referralCode: '0123456789ABCDEF'\n   * });\n   */\n  public async getRouteNonTokenized(\n    params: RouteNonTokenizedParams,\n  ): Promise<RouteData> {\n    const url = \"/shortcuts/route/nontokenized\";\n\n    return this.request<RouteData>({\n      method: \"GET\",\n      url,\n      params,\n    });\n  }\n\n  /**\n   * Gets IPOR shortcut transaction.\n   *\n   * Returns a transaction for IPOR shortcut operations.\n   *\n   * @param {Object} params - Parameters for the IPOR shortcut\n   * @param {number} [params.chainId] - Chain ID (optional)\n   * @param {string} params.fromAddress - Ethereum address of the wallet\n   * @param {IporShortcutInputData} data - IPOR shortcut input data\n   * @returns {Promise<IporShortcutData>} IPOR shortcut transaction data\n   * @throws {Error} If the API request fails\n   */\n  public async getIporShortcut(\n    params: { chainId?: number; fromAddress: string },\n    data: IporShortcutInputData,\n  ): Promise<IporShortcutData> {\n    const url = \"/shortcuts/static/ipor\";\n\n    return this.request<IporShortcutData>({\n      method: \"POST\",\n      url,\n      params,\n      data,\n    });\n  }\n\n  /**\n   * Gets all standards.\n   *\n   * Returns standards available for bundling. Each element represents a protocol, with list of supported actions and chains the standard's supported on.\n   *\n   * @returns {Promise<StandardData[]>} Array of standard data\n   * @throws {Error} If the API request fails\n   */\n  public async getStandards(): Promise<StandardData[]> {\n    const url = \"/standards\";\n\n    return this.request<StandardData[]>({\n      method: \"GET\",\n      url,\n    });\n  }\n\n  /**\n   * Gets standard by protocol slug.\n   *\n   * Returns a standard matching the given `slug`, containing supported actions, exact `inputs`, and a list of chains the standard's supported on.\n   *\n   * @param {string} slug - The protocol slug\n   * @returns {Promise<StandardData[]>} Array of standard data\n   * @throws {Error} If the API request fails\n   */\n  public async getStandardBySlug(slug: string): Promise<StandardData[]> {\n    const url = `/standards/${slug}`;\n\n    return this.request<StandardData[]>({\n      method: \"GET\",\n      url,\n    });\n  }\n\n  /**\n   * Gets all supported actions.\n   *\n   * Returns actions that can be bundled with `/shortcuts/bundle` endpoint. For specific protocol actions and exact action inputs, see `/actions/{slug}` endpoint.\n   *\n   * @returns {Promise<ActionData[]>} Array of action data\n   * @throws {Error} If the API request fails\n   */\n  public async getActions(): Promise<ActionData[]> {\n    const url = \"/actions\";\n\n    return this.request<ActionData[]>({\n      method: \"GET\",\n      url,\n    });\n  }\n\n  /**\n   * Gets actions for a specific protocol.\n   *\n   * @param {string} slug - The protocol slug\n   * @returns {Promise<ActionData[]>} Array of action data for the protocol\n   * @throws {Error} If the API request fails\n   */\n  public async getActionsBySlug(slug: string): Promise<ActionData[]> {\n    const url = `/actions/${slug}`;\n\n    return this.request<ActionData[]>({\n      method: \"GET\",\n      url,\n    });\n  }\n\n  /**\n   * Gets all non-tokenized positions.\n   *\n   * Returns a list of all nontokenized positions with details.\n   *\n   * @param {NonTokenizedParams} [params] - Optional parameters for filtering\n   * @returns {Promise<PaginatedNonTokenizedPositionData>} Paginated non-tokenized position data\n   * @throws {Error} If the API request fails\n   */\n  public async getNonTokenizedPositions(\n    params?: NonTokenizedParams,\n  ): Promise<PaginatedNonTokenizedPositionData> {\n    const url = \"/nontokenized\";\n\n    return this.request<PaginatedNonTokenizedPositionData>({\n      method: \"GET\",\n      url,\n      params,\n    });\n  }\n\n  /**\n   * Gets supported projects.\n   *\n   * Returns supported projects (e.g. `aave`) or platforms associated with available projects.\n   *\n   * @returns {Promise<Project[]>} Array of project data\n   * @throws {Error} If the API request fails\n   */\n  public async getProjects(): Promise<Project[]> {\n    const url = \"/projects\";\n\n    return this.request<Project[]>({\n      method: \"GET\",\n      url,\n    });\n  }\n\n  /**\n   * Gets protocols within a project.\n   *\n   * Returns all protocols available within the given project. For supported projects, see the `/projects` endpoint.\n   *\n   * @param {string} project - The project name\n   * @returns {Promise<ProtocolData[]>} Array of protocol data within the project\n   * @throws {Error} If the API request fails\n   */\n  public async getProtocolsByProject(project: string): Promise<ProtocolData[]> {\n    const url = `/projects/${project}/protocols`;\n\n    return this.request<ProtocolData[]>({\n      method: \"GET\",\n      url,\n    });\n  }\n\n  /**\n   * Gets supported networks.\n   *\n   * Returns networks supported by Enso.\n   *\n   * @param {NetworkParams} [params] - Optional parameters for filtering networks\n   * @returns {Promise<ConnectedNetwork[]>} Array of network data\n   * @throws {Error} If the API request fails\n   */\n  public async getNetworks(\n    params?: NetworkParams,\n  ): Promise<ConnectedNetwork[]> {\n    const url = \"/networks\";\n\n    return this.request<ConnectedNetwork[]>({\n      method: \"GET\",\n      url,\n      params,\n    });\n  }\n\n  /**\n   * Gets supported aggregators.\n   *\n   * Fetches aggregators supported by Enso.\n   *\n   * @param {number} [chainId] - Chain ID to filter aggregators for\n   * @returns {Promise<string[]>} Array of aggregator names\n   * @throws {Error} If the API request fails\n   */\n  public async getAggregators(chainId?: number): Promise<string[]> {\n    const url = \"/aggregators\";\n    const params = chainId ? { chainId } : undefined;\n\n    return this.request<string[]>({\n      method: \"GET\",\n      url,\n      params,\n    });\n  }\n\n  /**\n   * Gets volume data for a chain.\n   *\n   * Returns total USD and transactions volume for the given chainId.\n   *\n   * @param {number} chainId - Chain ID to get volume for\n   * @returns {Promise<unknown>} Volume data\n   * @throws {Error} If the API request fails\n   */\n  public async getVolume(chainId: number): Promise<unknown> {\n    const url = `/volume/${chainId}`;\n\n    return this.request<unknown>({\n      method: \"GET\",\n      url,\n    });\n  }\n\n  public async getAccountId(): Promise<string> {\n    const url = `/account/accountId`;\n\n    return this.request<string>({\n      method: \"GET\",\n      url,\n    });\n  }\n}\n\n// Custom error classes\nexport class EnsoApiError extends Error {\n  constructor(\n    message: string,\n    public statusCode: number,\n    public responseData?: any,\n  ) {\n    super(message);\n    this.name = \"EnsoApiError\";\n  }\n}\n"],"mappings":"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","names":["axios"]}